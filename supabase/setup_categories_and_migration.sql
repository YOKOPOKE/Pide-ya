-- 1. Crear tabla categories si no existe
CREATE TABLE IF NOT EXISTS public.categories (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name TEXT NOT NULL,
    slug TEXT UNIQUE NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL
);

-- 2. Habilitar seguridad (RLS)
ALTER TABLE public.categories ENABLE ROW LEVEL SECURITY;

-- Política de lectura pública (cualquiera puede ver categorías)
DROP POLICY IF EXISTS "Public read access" ON public.categories;
CREATE POLICY "Public read access" ON public.categories FOR SELECT USING (true);

-- Política de escritura (solo autenticados/admin pueden crear/editar)
-- Ajusta esto según tus necesidades de auth, por defecto permitimos a autenticados para que el Admin funcione
DROP POLICY IF EXISTS "Admin write access" ON public.categories;
CREATE POLICY "Admin write access" ON public.categories FOR ALL USING (auth.role() = 'authenticated');

-- 3. MIGRACION INTELIGENTE: Mover categorías de texto a la nueva tabla
DO $$
BEGIN
    -- Si existe la columna antigua 'category' en products
    IF EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'products' AND column_name = 'category') THEN
        
        -- Insertar categorias únicas que ya existen en los productos
        INSERT INTO public.categories (name, slug)
        SELECT DISTINCT category, lower(regexp_replace(category, '[^a-zA-Z0-9]+', '-', 'g'))
        FROM public.products
        WHERE category IS NOT NULL 
        AND category != ''
        AND category != 'General' -- Ignorar 'General' si prefieres
        ON CONFLICT (slug) DO NOTHING;
        
    END IF;
END $$;

-- 4. Asegurar categorías base (por si acaso no existían)
INSERT INTO public.categories (name, slug) VALUES 
('Pokes de la Casa', 'bowls'),
('Sushi Burgers', 'burgers'),
('Entradas', 'entradas'),
('Bebidas', 'bebidas'),
('Postres', 'postres')
ON CONFLICT (slug) DO NOTHING;

-- 5. Agregar columna category_id a products y vincularla
ALTER TABLE public.products ADD COLUMN IF NOT EXISTS category_id BIGINT REFERENCES public.categories(id);

-- 6. VINCULAR DATA: Conectar productos con sus nuevas categorías
DO $$
BEGIN
    -- Vincular por coincidencia exacta de nombre
    IF EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'products' AND column_name = 'category') THEN
        UPDATE public.products p
        SET category_id = c.id
        FROM public.categories c
        WHERE lower(p.category) = lower(c.name)
        AND p.category_id IS NULL;
    END IF;
    
    -- Fallback 1: Vincular por tipo interno 'poke' -> 'bowls'
    UPDATE public.products 
    SET category_id = (SELECT id FROM public.categories WHERE slug = 'bowls') 
    WHERE category_id IS NULL AND type = 'poke';

    -- Fallback 2: Vincular por tipo interno 'burger' -> 'burgers'
    UPDATE public.products 
    SET category_id = (SELECT id FROM public.categories WHERE slug = 'burgers') 
    WHERE category_id IS NULL AND type = 'burger';

END $$;

-- 7. IMPORTANTE: Habilitar Realtime para que el menú se actualice solo
-- Primero verificamos si la publicación existe, si no la alteramos
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_publication_tables WHERE pubname = 'supabase_realtime' AND tablename = 'categories') THEN
        ALTER PUBLICATION supabase_realtime ADD TABLE public.categories;
    END IF;
END $$;

-- Confirmación
SELECT COUNT(*) as categories_count FROM public.categories;
